<!DOCTYPE html>
<html lang="en" class="dark"> <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MedTracker - Kanban Board</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* Custom styles */
        body {
            font-family: 'Inter', sans-serif;
            /* Dark mode background */
            background-color: #1f2937; /* gray-800 */
        }
        .kanban-column {
            min-height: 300px; /* Ensure columns have a minimum height */
            transition: background-color 0.2s ease-in-out; /* Smooth transition for dragover */
            /* Dark mode column background */
            background-color: #374151; /* gray-700 */
        }
        .task-card {
            cursor: grab; /* Indicate draggable item */
            transition: transform 0.2s ease, box-shadow 0.2s ease; /* Smooth transition for dragging */
            position: relative; /* Needed for absolute positioning of the delete button */
            padding-right: 2.5rem; /* Make space for the delete button */
             /* Dark mode task card background and text */
            background-color: #4b5563; /* gray-600 */
            color: #f3f4f6; /* gray-100 */
            border-color: #52525b; /* zinc-600 */
        }
        .task-card:active {
            cursor: grabbing; /* Indicate grabbing state */
            transform: scale(1.03); /* Slightly enlarge card when grabbed */
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.3), 0 4px 6px -2px rgba(0, 0, 0, 0.2); /* Darker shadow */
        }
        .delete-button {
            position: absolute;
            top: 0.5rem; /* Adjust as needed */
            right: 0.5rem; /* Adjust as needed */
            background: none;
            border: none;
            color: #9ca3af; /* gray-400 */
            font-size: 1.2rem; /* Slightly larger 'X' */
            font-weight: bold;
            cursor: pointer;
            padding: 0.25rem; /* Add some padding for easier clicking */
            line-height: 1; /* Ensure 'X' is centered vertically */
            transition: color 0.2s ease;
        }
        .delete-button:hover {
            color: #f87171; /* red-400 */
        }
        .dragging {
            opacity: 0.6; /* Adjust opacity for dark mode */
        }
        .drag-over {
             /* Dark mode highlight on drag over */
            background-color: #4b5563; /* gray-600 */
        }
        /* Confetti Canvas */
        #confetti-canvas {
            position: fixed; /* Position relative to the viewport */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1000; /* Ensure it's on top */
            pointer-events: none; /* Allow clicks to pass through */
            display: none; /* Hidden by default */
        }
    </style>
</head>
<body class="p-4 md:p-8">

    <h1 class="text-3xl font-bold text-center text-gray-100 mb-8">MedTracker</h1>

    <div class="mb-8 max-w-md mx-auto bg-gray-700 p-4 rounded-lg shadow-lg">
        <h2 class="text-lg font-semibold mb-2 text-gray-200">Add New Task</h2>
        <div class="flex space-x-2">
            <input type="text" id="new-task-input" placeholder="Enter task description..." class="flex-grow border border-gray-500 bg-gray-600 text-gray-100 p-2 rounded-md focus:outline-none focus:ring-2 focus:ring-indigo-500 placeholder-gray-400">
            <button id="add-task-button" class="bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-2 px-4 rounded-md transition duration-150 ease-in-out">
                Add Task
            </button>
        </div>
    </div>

    <div class="grid grid-cols-1 md:grid-cols-3 gap-6 max-w-6xl mx-auto">
        <div id="todo-column" class="kanban-column p-4 rounded-lg shadow-md">
            <h2 class="text-xl font-semibold mb-4 text-center text-gray-200 border-b border-gray-500 pb-2">To Do</h2>
            <div id="todo-tasks" class="space-y-3 min-h-[200px]">
                </div>
        </div>

        <div id="inprogress-column" class="kanban-column p-4 rounded-lg shadow-md">
            <h2 class="text-xl font-semibold mb-4 text-center text-gray-200 border-b border-gray-500 pb-2">In Progress</h2>
            <div id="inprogress-tasks" class="space-y-3 min-h-[200px]">
                 </div>
        </div>

        <div id="done-column" class="kanban-column p-4 rounded-lg shadow-md">
            <h2 class="text-xl font-semibold mb-4 text-center text-gray-200 border-b border-gray-500 pb-2">Done ðŸŽ‰</h2>
            <div id="done-tasks" class="space-y-3 min-h-[200px]">
                 </div>
        </div>
    </div>

    <canvas id="confetti-canvas"></canvas>

    <script>
        // --- DOM Elements ---
        const newTaskInput = document.getElementById('new-task-input');
        const addTaskButton = document.getElementById('add-task-button');
        const todoTasks = document.getElementById('todo-tasks');
        const inProgressTasks = document.getElementById('inprogress-tasks');
        const doneTasks = document.getElementById('done-tasks');
        const columns = document.querySelectorAll('.kanban-column');
        const taskContainers = document.querySelectorAll('.kanban-column > div'); // Get the actual task containers

        // --- Task Management ---
        let taskIdCounter = 1; // Reset counter for simplicity with initial tasks

        // Function to create a new task element
        function createTaskElement(taskText, taskId) {
            const taskCard = document.createElement('div');
            // Using Tailwind classes directly now for consistency
            taskCard.className = 'task-card bg-gray-600 p-3 rounded-md shadow border border-zinc-600 text-gray-100'; // Apply dark mode classes
            taskCard.setAttribute('draggable', 'true');
            taskCard.setAttribute('data-task-id', `task-${taskId}`);

            // Create span for task text
            const taskTextSpan = document.createElement('span');
            taskTextSpan.textContent = taskText;
            taskCard.appendChild(taskTextSpan);

            // Create delete button
            const deleteBtn = document.createElement('button');
            deleteBtn.classList.add('delete-button'); // Style applied via CSS
            deleteBtn.innerHTML = '&times;'; // Use HTML entity for 'X'
            deleteBtn.setAttribute('aria-label', 'Delete task'); // Accessibility
            deleteBtn.onclick = function() {
                // Optional: Add confirmation dialog
                // if (confirm(`Are you sure you want to delete task: "${taskText}"?`)) {
                    taskCard.remove(); // Remove the task card element
                // }
            };
            taskCard.appendChild(deleteBtn);


            // Add drag event listeners to the new task
            addDragListeners(taskCard);

            return taskCard;
        }

        // Function to add a new task via input
        function addTaskFromInput() {
            const taskText = newTaskInput.value.trim();
            if (taskText === '') {
                // Consider replacing alert with a styled modal integrated into the dark theme
                alert("Please enter a task description.");
                return;
            }

            const newTask = createTaskElement(taskText, taskIdCounter++);
            todoTasks.appendChild(newTask); // Add new tasks to the "To Do" column by default
            newTaskInput.value = ''; // Clear the input field
        }

        // Event listener for the Add Task button
        addTaskButton.addEventListener('click', addTaskFromInput);

        // Event listener for pressing Enter in the input field
        newTaskInput.addEventListener('keypress', function(event) {
            if (event.key === 'Enter') {
                addTaskFromInput();
            }
        });

        // --- Drag and Drop Functionality ---
        let draggedItem = null; // Variable to store the element being dragged
        let sourceColumnId = null; // Keep track of the source column

        // Function to add drag listeners to a task card
        function addDragListeners(taskCard) {
            taskCard.addEventListener('dragstart', (e) => {
                 // Prevent dragging if the delete button was the drag initiator
                 if (e.target.classList.contains('delete-button')) {
                    e.preventDefault();
                    return;
                 }
                draggedItem = taskCard;
                sourceColumnId = taskCard.closest('.kanban-column > div').id; // Get the ID of the parent task container (e.g., 'todo-tasks')
                setTimeout(() => taskCard.classList.add('dragging'), 0); // Add dragging style with a slight delay
            });

            taskCard.addEventListener('dragend', () => {
                // Ensure draggedItem is not null before trying to remove class
                if(draggedItem) {
                    setTimeout(() => { // Use timeout to ensure styles are applied after drop logic
                        draggedItem.classList.remove('dragging');
                        draggedItem = null;
                        sourceColumnId = null; // Reset source column
                    }, 0);
                }
                 // Clean up any lingering drag-over styles on columns
                 columns.forEach(col => col.classList.remove('drag-over'));
            });
        }

        // Add dragover and drop listeners to task containers within columns
        taskContainers.forEach(container => {
            container.addEventListener('dragover', (e) => {
                e.preventDefault(); // Necessary to allow dropping
                const targetColumnElement = container.parentElement; // The actual column element
                targetColumnElement.classList.add('drag-over'); // Highlight the column

                const afterElement = getDragAfterElement(container, e.clientY);

                // Only append if we have a valid dragged item
                if (draggedItem) {
                    if (afterElement == null) {
                         container.appendChild(draggedItem);
                    } else {
                         container.insertBefore(draggedItem, afterElement);
                    }
                }
            });

             container.addEventListener('dragleave', (e) => {
                 const targetColumnElement = container.parentElement;
                 // Check if the related target (where the mouse is going) is outside the current column
                 // This prevents flickering when moving over child elements (the tasks)
                 if (!targetColumnElement.contains(e.relatedTarget)) {
                    targetColumnElement.classList.remove('drag-over'); // Remove highlight only when leaving the column entirely
                 }
             });

            container.addEventListener('drop', (e) => {
                e.preventDefault(); // Prevent default drop behavior
                const targetColumnElement = container.parentElement;
                targetColumnElement.classList.remove('drag-over'); // Remove highlight

                if (draggedItem) {
                    const targetTasksContainerId = container.id; // e.g., 'done-tasks'

                    // Check if the task was dropped into the "Done" column AND wasn't already there
                    if (targetTasksContainerId === 'done-tasks' && sourceColumnId !== 'done-tasks') {
                        triggerConfetti();
                    }
                    // The actual move happens during 'dragover' for smoother visual feedback
                }
                 // Reset source column ID after drop is complete
                 sourceColumnId = null;
            });
        });

        // Helper function to determine where to insert the dragged item
        function getDragAfterElement(container, y) {
            const draggableElements = [...container.querySelectorAll('.task-card:not(.dragging)')];

            return draggableElements.reduce((closest, child) => {
                const box = child.getBoundingClientRect();
                const offset = y - box.top - box.height / 2;
                // Find the element directly below the cursor
                if (offset < 0 && offset > closest.offset) {
                    return { offset: offset, element: child };
                } else {
                    return closest;
                }
            }, { offset: Number.NEGATIVE_INFINITY }).element;
        }


        // --- Confetti Animation ---
        // (Confetti code remains the same - no visual changes needed for dark mode)
        const confettiCanvas = document.getElementById('confetti-canvas');
        const ctx = confettiCanvas.getContext('2d');
        let particles = [];
        let animationFrameId = null;

        class Particle {
             constructor(x, y) {
                this.x = x;
                this.y = y;
                this.size = Math.random() * 7 + 3;
                this.speedX = Math.random() * 6 - 3;
                this.speedY = Math.random() * -15 - 5;
                // Keep bright colors for confetti contrast against dark background
                this.color = `hsl(${Math.random() * 360}, 100%, 60%)`; // Slightly brighter maybe
                this.opacity = 1;
                this.gravity = 0.3;
                this.drag = 0.98;
                this.spin = Math.random() * 0.2 - 0.1;
                this.angle = 0;
            }
            update() {
                this.speedY += this.gravity;
                this.speedX *= this.drag;
                this.speedY *= this.drag;
                this.x += this.speedX;
                this.y += this.speedY;
                this.opacity -= 0.01;
                this.angle += this.spin;
            }
            draw() {
                ctx.save();
                ctx.globalAlpha = this.opacity;
                ctx.translate(this.x + this.size / 2, this.y + this.size / 2);
                ctx.rotate(this.angle);
                ctx.fillStyle = this.color;
                ctx.fillRect(-this.size / 2, -this.size / 2, this.size, this.size);
                ctx.restore();
            }
        }

        function createParticles() {
            particles = [];
            const particleCount = 150;
            const centerX = confettiCanvas.width / 2;
            const centerY = confettiCanvas.height * 0.2;
            for (let i = 0; i < particleCount; i++) {
                particles.push(new Particle(centerX, centerY));
            }
        }

        function animateConfetti() {
            confettiCanvas.width = window.innerWidth;
            confettiCanvas.height = window.innerHeight;
            ctx.clearRect(0, 0, confettiCanvas.width, confettiCanvas.height);
            particles.forEach((particle, index) => {
                particle.update();
                particle.draw();
                if (particle.opacity <= 0 || particle.y > confettiCanvas.height) {
                    particles.splice(index, 1);
                }
            });
            if (particles.length > 0) {
                animationFrameId = requestAnimationFrame(animateConfetti);
            } else {
                confettiCanvas.style.display = 'none';
                animationFrameId = null;
            }
        }

        function triggerConfetti() {
            confettiCanvas.style.display = 'block';
            confettiCanvas.width = window.innerWidth;
            confettiCanvas.height = window.innerHeight;
            createParticles();
            if (!animationFrameId) {
                 animateConfetti();
            }
        }

        // --- Initial Setup ---
        function initializeBoard() {
            // Add some initial example tasks
            const initialTasks = [
                { text: "Schedule check-up", column: todoTasks },
                { text: "Refill prescription", column: inProgressTasks },
                { text: "Take morning pills", column: doneTasks }
            ];

            initialTasks.forEach(task => {
                const taskElement = createTaskElement(task.text, taskIdCounter++);
                task.column.appendChild(taskElement);
            });
        }

        // Initialize the board when the script runs
        initializeBoard();

    </script>

</body>
</html>
